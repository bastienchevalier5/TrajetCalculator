@inject DatabaseService DatabaseService
@using Microsoft.AspNetCore.Components.Forms

@page "/route-planner"

<div class="text-center pt-2 d-flex flex-column align-items-center"
     style="
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        border-radius:20px;
        max-width: 500px;
        width: 100%;
    ">
    <div class="bg-secondary" style="width:80px;height:5px;border-radius:20px;"></div>
    <div class="route-container w-100 overflow-auto" style="max-height: 400px;">
        <form class="d-flex flex-column gap-2 p-4 rounded-4 position-relative">
            <!-- Ligne pointillée verticale -->
            <div class="position-absolute" style="left: 41px; top: 40px; bottom: 40px; width: 2px; border-left: 2px dashed #6c757d; z-index: 1;"></div>

            <!-- Ville de départ -->
            <div class="d-flex gap-4 align-items-center position-relative" style="z-index: 2;">
                <div class="d-flex justify-content-center align-items-center rounded-circle bg-secondary p-2" style="max-height:36px; width: 36px;">
                    <i class="bi bi-geo-alt-fill text-white m-0"></i>
                </div>
                <input type="text" @bind="SelectedDepartureId" @oninput="FilterCommunes"
                       placeholder="Ville de départ"
                       list="communesList"
                       class="input-route bg-transparent p-2 border border-secondary text-white w-100"
                       style="border-radius:50px; transition: all 0.3s ease;">
            </div>

            <!-- Étapes intermédiaires générées dynamiquement -->
            @foreach (var waypoint in Waypoints)
            {
                <div class="d-flex gap-4 align-items-center position-relative" style="z-index: 2;">
                    <div class="d-flex justify-content-center align-items-center rounded-circle bg-secondary p-2" style="max-height:36px; width: 36px;">
                        <i class="bi bi-circle-fill text-white m-0"></i>
                    </div>
                    <input type="text" @bind="waypoint.Label" @oninput="FilterCommunes"
                           placeholder="Étape intermédiaire"
                           list="communesList"
                           class="input-route bg-transparent p-2 border border-secondary text-white w-100"
                           style="border-radius:50px; transition: all 0.3s ease;">
                    <button type="button" class="p-0 btn btn-sm bg-transparent border-0 position-relative"
                            @onclick="() => RemoveWaypoint(waypoint.Id)"
                            style="border: 2px solid red; border-radius: 50%; transition: box-shadow 0.3s ease;"
                            onfocus="this.blur();">
                        <i class="bi bi-x-circle-fill text-danger m-0"></i>
                    </button>
                </div>
            }

            <!-- Bouton d'ajout d'étape -->
            <div class="m-2" style="z-index: 2;">
                <button type="button" class="bg-secondary rounded-circle" style="width:30px;height:30px;border:none" @onclick="AddWaypoint">
                    <p class="text-white m-0 p-0">+</p>
                </button>
            </div>

            <!-- Ville d'arrivée -->
            <div class="d-flex gap-4 align-items-center position-relative" style="z-index: 2;">
                <div class="d-flex justify-content-center align-items-center rounded-circle bg-secondary p-2" style="max-height:36px; width: 36px;">
                    <i class="bi bi-flag-fill text-white m-0"></i>
                </div>
                <input type="text" @bind="SelectedArrivalId" @oninput="FilterCommunes"
                       placeholder="Ville d'arrivée"
                       list="communesList"
                       class="input-route bg-transparent p-2 border border-secondary text-white w-100"
                       style="border-radius:50px; transition: all 0.3s ease;">
            </div>
        </form>
    </div>

    <!-- Liste des villes filtrées pour l'auto-complétion -->
    <datalist id="communesList">
        @foreach (var commune in FilteredCommunes)
        {
            <option value="@commune.Label (@commune.ZipCode)"></option>
        }
    </datalist>
</div>

@code {
    private int? SelectedDepartureId;
    private int? SelectedArrivalId;
    private List<Commune> AllCommunes = new();
    private List<Commune> FilteredCommunes = new();
    private List<Waypoint> Waypoints = new();

    protected override async Task OnInitializedAsync()
    {
        // Récupérer la liste des communes et les trier par ordre alphabétique
        AllCommunes = (await DatabaseService.GetCommunesAsync()).OrderBy(c => c.Label).ToList();
        FilteredCommunes = AllCommunes;
    }

    private void FilterCommunes(ChangeEventArgs e)
    {
        string searchText = e.Value?.ToString()?.Trim() ?? "";

        if (string.IsNullOrEmpty(searchText))
        {
            FilteredCommunes = AllCommunes;
            return;
        }

        // Commence par le texte saisi
        var startsWith = AllCommunes
            .Where(c => c.Label.StartsWith(searchText, StringComparison.OrdinalIgnoreCase))
            .ToList();

        // Contient le texte saisi mais ne commence pas par celui-ci
        var contains = AllCommunes
            .Where(c => c.Label.Contains(searchText, StringComparison.OrdinalIgnoreCase) &&
                        !startsWith.Contains(c))
            .ToList();

        // Fusionner les résultats
        FilteredCommunes = startsWith.Concat(contains).ToList();
    }


    private void AddWaypoint()
    {
        Waypoints.Add(new Waypoint { Id = Waypoints.Count + 1 });
    }

    private void RemoveWaypoint(int id)
    {
        Waypoints.RemoveAll(w => w.Id == id);
    }

    public class Waypoint
    {
        public int Id { get; set; }
        public string Label { get; set; } = "";
    }

    private async Task<List<string>> CalculItineraire(int Departure, List<int> Waypoints, int Arrival)
    {
        if (!SelectedDepartureId.HasValue || !SelectedArrivalId.HasValue) return new List<string> { "Veuillez sélectionner une ville de départ et une ville d'arrivée." };

        var departure = await DatabaseService.GetCommuneByIdAsync(Departure);
        var arrival = await DatabaseService.GetCommuneByIdAsync(Arrival);
        var waypoints = new List<Commune>();

        foreach (var waypoint in Waypoints)
        {
            if (waypoint != 0)
                waypoints.Add(await DatabaseService.GetCommuneByIdAsync(waypoint));
        }

        var shortestPath = await FindOptimalRoute(AllCommunes, departure.Label, waypoints.Select(v => v.Label).ToList(), arrival.Label);

        return shortestPath;
    }

    public async Task<List<string>> FindOptimalRoute(List<Commune> communes, string start, List<string> required, string end)
    {
        double minDistance = double.MaxValue;
        List<string> ?bestRoute = null;

        foreach (var perm in GetPermutations(required, required.Count))
        {
            List<string> route = new List<string> { start };
            route.AddRange(perm);
            route.Add(end);

            double totalDistance = 0;
            bool validRoute = true;

            for (int i = 0; i < route.Count - 1; i++)
            {
                var subPath = Dijkstra(communes, route[i], route[i + 1]);
                if (subPath.Count == 0)
                {
                    validRoute = false;
                    break;
                }
                totalDistance += subPath.Count - 1;
            }

            if (validRoute && totalDistance < minDistance)
            {
                minDistance = totalDistance;
                bestRoute = new List<string>(route);
            }
        }

        return bestRoute ?? new List<string>();
    }

    public List<string> Dijkstra(List<Commune> communes, string start, string end)
    {
        var distances = new Dictionary<string, double>();
        var previous = new Dictionary<string, string>();
        var pq = new SortedSet<(double, string)>();

        foreach (var commune in communes)
        {
            distances[commune.Label] = double.MaxValue;
        }
        distances[start] = 0;
        pq.Add((0, start));

        while (pq.Count > 0)
        {
            var (dist, current) = pq.Min;
            pq.Remove(pq.Min);

            if (current == end) break;

            var currentCommune = communes.First(v => v.Label == current);

            foreach (var neighbor in communes)
            {
                if (neighbor.Label == current) continue;

                double newDist = dist + CalculDistanceVille(currentCommune, neighbor);
                if (newDist < distances[neighbor.Label])
                {
                    pq.Remove((distances[neighbor.Label], neighbor.Label));
                    distances[neighbor.Label] = newDist;
                    previous[neighbor.Label] = current;
                    pq.Add((newDist, neighbor.Label));
                }
            }
        }

        return ReconstructPath(previous, start, end);
    }

    private List<string> ReconstructPath(Dictionary<string, string> previous, string start, string end)
    {
        var path = new List<string>();
        for (string at = end; at != null; at = previous.GetValueOrDefault(at))
        {
            path.Add(at);
        }
        path.Reverse();
        return path.Count > 1 ? path : new List<string>();
    }

    static IEnumerable<IEnumerable<T>> GetPermutations<T>(IEnumerable<T> list, int length)
    {
        if (length == 1) return list.Select(t => new T[] { t });

        return GetPermutations(list, length - 1)
            .SelectMany(t => list.Where(e => !t.Contains(e)),
                        (t1, t2) => t1.Concat(new T[] { t2 }));
    }

    private double CalculDistanceVille(Commune Departure, Commune Arrival)
    {
        const double kmPerDegree = 111.0;

        double deltaLatitude = (double)(Arrival.Latitude - Departure.Latitude);
        double deltaLongitude = (double)(Arrival.Longitude - Departure.Longitude);

        double averageLatitudeRad = (Math.PI / 180) * ((double)(Departure.Latitude + Arrival.Latitude) / 2.0);

        double deltaX = kmPerDegree * deltaLatitude;
        double deltaY = kmPerDegree * Math.Cos(averageLatitudeRad) * deltaLongitude;

        return Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
    }
}

